# Orchestrations

You can use orchestrations to orchestrate the execution of other orchestrations, [entities](entities.md),
and [activities](activities.md). Orchestrations have the following characteristics:

- Orchestrations declare workflows using imperative code, without any declarative schemas.
- Orchestrations can call other idempotent functions synchronously, or call other durable code asynchronously. Output
  gathered from other functions can be reliably saved in local variables.
- Orchestrator execution state is checkpointed at each context->await, and is always replayed to regain the current
  state.
- Orchestrators can be long-running, spanning seconds, months, years, or infinite time, without consuming resources
  while waiting on the next event.

## Identity

Every instance of an orchestration has a unique instance identifier. By default, each instance id is a generated uuid.
However, you can also use any string value as an identifier, but note that these identifiers must be unique. Multiple
instances with the same identifier is an **undefined behavior**.

> Note:
>
> It is recommended to use autogenerated ids as much as possible. User generated instance ids are intended for cases
> where there is a one-to-one mapping between an orchestration and some external system, for example, order ids or a
> document.

An orchestration instance id is required for most instance management operations (getting the current status, sending
events, etc.). Thus it is recommended to store them somewhere you can reference them, such as logs, a database, or
entity.

## Reliability

Orchestrations reliably maintain their execution state using composable event-sourcing and snapshotting. This allows for
orchestrations to perform in an eventually consistent way, without relying on the specific order of events.

The event-sourcing implementation is mostly transparent. Behind the scenes, waiting on a value will yield control of the
application to Durable PHP's dispatcher (via a custom exception), which will return a previously received result, or
request a result from somewhere else. Once the orchestration has gone as far as it can with the events it has received,
it abandons further execution and performs a three-phase commit: first, committing transaction history to storage, then
dispatching any generated events, and finally, acknowledging the event it is currently processing. A catastrophic
failure will result in a log message, no commit to storage, and the current event sent to the dead-letter queue.

When the orchestrator is given more work to do (for example, an activity result or external event), Durable PHP re-runs
the entire function from the start to rebuild local state. During replay, if the function tries to wait on an
asynchronous result, Durable PHP consults the previous events and returns the expected result (or throws the received
exception). Replay continues until it can no longer, and the cycle repeats.

> Note:
>
> In order for replaying to work correctly and reliably, it is **extremely** important that the code being replayed is
> deterministic. Non-deterministic code can result in errors, infinite loops, and other unexpected behavior. Even
> logging must be deterministic and you can get a replay-aware logger from the orchestration context.

## Changing orchestration implementation

Due to the nature of replaying events and event-sourcing, the code you write is **strongly coupled** to the past. Take
for example:

```php
function example(\Bottledcode\DurablePhp\OrchestrationContext $context): void {
    $hello = $context->callActivity('hello', $context->getInput()['name']);
}
```

and then later you change it to:

```php
function example(\Bottledcode\DurablePhp\OrchestrationContext $context): void {
    $goodbye = $context->callActivity('goodbye', $context->getInput()['name']);
    $hello = $context->callActivity('hello', $context->getInput()['name']);
}
```

Any executions currently running would not see an output for the `goodbye` activity and would call that activity, even
if they would have previously completed execution upon receiving a response from `hello`. You must be very careful when
making changes to orchestrations. It is generally recommended to version your orchestrations, then delete the old
versions once all instances are completed.

```php
function example(\Bottledcode\DurablePhp\OrchestrationContext $context): void {
    $hello = $context->callActivity('hello', $context->getInput()['name']);
}
function exampleV2(\Bottledcode\DurablePhp\OrchestrationContext $context): void {
    $goodbye = $context->callActivity('goodbye', $context->getInput()['name']);
    $hello = $context->callActivity('hello', $context->getInput()['name']);
}
```

This isn't strictly necessary for all cases, but it is something to keep in mind and ensure you test before deploying to
production.

## State Snapshots

After every invocation, the current execution state is snapshotted and stored in the `orchestrations` table.

todo.

## Features

### Sub-orchestrations

Not implemented

## Timers

Orchestrations can schedule timers to implement delays or configure timeouts. Use timers instead of natively sleeping.

See [timers](timers.md) for more information.

## External events

Orchestrations can be sent events from client code, this is useful for handling human interaction or external
callbacks/webhooks.

See [external events](external-events.md) for more information.

## Error handling

Exceptions are marshaled to your code and rethrown in your orchestration. Thus, you can use regular try/catch blocks to
handle failures. If you do not catch a rethrown exception, the orchestration will enter the `Failed` state.

> Note:
>
> The `failed` state is a terminal state and cannot be retried.

## Critical sections

Orchestrations are "single-threaded" and thus you don't need to worry about race conditions **within** an orchestration.
However, race conditions are certainly possible when interacting with external systems or entities. To help with dealing
with race conditions, you may "lock" an entity. When an entity is locked, only the orchestration instance that locked
the entity may perform actions on the entity. Any other actions on the entity (including other lock requests), are
queued until the lock is released or the orchestration ends.

Here's an example showing a lock:

```php
function orch(\Bottledcode\DurablePhp\OrchestrationContext $context): void {
    $entityId = new \Bottledcode\DurablePhp\State\EntityId('myEntity', 'id');
    $lock = $context->lockEntity($entityId);
    // from here-on, you have exclusive access to the entity
    $context->entityOp($entityId, fn($entity) => $entity->add(5));
    $isLocked = $lock->isLocked(); // always true until ->unlock() is called
    $lock->unlock();
    // the lock is released
}
```

Locking is a very expensive operation (taking at least 3 events), and usually isn't needed since [entities](entities.md)
are "single-threaded" as well. Once a lock is held, no other signal sent by another orchestration, entity, or client
will be received by the locked entity until it is unlocked.

## Class style orchestrations

There are times where you need DI to inject services for an orchestration. In these cases, it's best to use a "Class
Style" orchestration:

```php
class MyOrchestration {
    public function __construct(private MyService $service, private \Bottledcode\DurablePhp\OrchestrationContext $context) {}
    
    #[\Bottledcode\DurablePhp\State\Attributes\EntryPoint]
    public function run(int $input1, string $input2) {
        // perform work
    }
    
    // alternatively, you can forego the EntryPoint attribute and just implement __invoke()
}
```
